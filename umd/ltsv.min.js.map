{"version":3,"file":"ltsv.min.js","sources":["../src/validator.mjs","../src/formatter.mjs","../src/parser.mjs"],"sourcesContent":["/**\n * @file LTSV validator.\n * @module validator\n */\n\n/**\n * validate label.\n *\n * @param {string} label\n * @returns {boolean}\n */\nexport function isValidLabel(label) {\n  return /^[0-9A-Za-z_.-]+$/.test(label);\n}\n\n/**\n * validate for value.\n *\n * @param {string} value\n * @returns {boolean}\n */\nexport function isValidValue(value) {\n  // eslint-disable-next-line no-control-regex\n  return /^[\\x01-\\x08\\x0B\\x0C\\x0E-\\xFF]*$/.test(value);\n}\n","/**\n * @file LTSV formatter.\n * @module formatter\n */\n\nimport { isValidLabel, isValidValue } from './validator.mjs';\n\n/**\n * convert to record string from object.\n *\n * @private\n * @param {Object} object\n * @param {boolean} strict\n * @returns {string}\n * @throws {TypeError}\n */\nfunction objectToRecord(object, strict) {\n  if (object === null || typeof object !== 'object') {\n    throw new TypeError('object must be an Object');\n  }\n\n  const keys = Object.keys(object);\n  const fields = [];\n\n  for (let i = 0, len = keys.length; i < len; ++i) {\n    const label = keys[i];\n    const value = object[keys[i]];\n\n    if (strict && !isValidLabel(label)) {\n      throw new SyntaxError(`unexpected character of label: \"${label}\"`);\n    }\n\n    if (strict && !isValidValue(value)) {\n      throw new SyntaxError(`unexpected character of value: \"${value}\"`);\n    }\n\n    fields[i] = label + ':' + value;\n  }\n\n  return fields.join('\\t');\n}\n\n/**\n * convert to LTSV string from object or array.\n *\n * @private\n * @param {Object|Object[]} data\n * @param {boolean} strict\n * @returns {string}\n * @throws {TypeError}\n */\nfunction baseFormat(data, strict) {\n  const isArray = Array.isArray(data);\n\n  if (!isArray && (data === null || typeof data !== 'object')) {\n    throw new TypeError('data must be an Object or Array');\n  }\n\n  const records = [];\n\n  if (isArray) {\n    for (let i = 0, len = data.length; i < len; ++i) {\n      records[i] = objectToRecord(data[i], strict);\n    }\n  } else {\n    records.push(objectToRecord(data, strict));\n  }\n\n  return records.join('\\n');\n}\n\n/**\n * convert to LTSV string from object or array.\n *\n * @param {Object|Object[]} data\n * @returns {string}\n * @see baseFormat\n */\nexport function format(data) {\n  return baseFormat(data, false);\n}\n\n/**\n * convert to LTSV string from object or array.\n *\n * @param {Object|Object[]} data\n * @returns {string}\n * @see baseFormat\n */\nexport function formatStrict(data) {\n  return baseFormat(data, true);\n}\n\n/**\n * convert to LTSV string from object or array.\n *\n * @param {Object|Object[]} data\n * @param {Object} options\n * @param {boolean} [options.strict=false]\n * @returns {string}\n * @see baseFormat\n */\nexport function stringify(data, options = {}) {\n  const { strict = false } = options;\n\n  return baseFormat(data, strict);\n}\n","/**\n * @file LTSV parser.\n * @module parser\n */\n\nimport { isValidLabel, isValidValue } from './validator.mjs';\n\n/**\n * split to label and value from field.\n *\n * @private\n * @param {string} chunk\n * @param {boolean} strict\n * @returns {Object}\n * @throws {SyntaxError}\n */\nfunction splitField(chunk, strict) {\n  const field = String(chunk);\n  const index = field.indexOf(':');\n\n  if (index === -1) {\n    throw new SyntaxError(`field separator is not found: \"${field}\"`);\n  }\n\n  const label = field.slice(0, index);\n  const value = field.slice(index + 1);\n\n  if (strict && !isValidLabel(label)) {\n    throw new SyntaxError(`unexpected character of label: \"${label}\"`);\n  }\n\n  if (strict && !isValidValue(value)) {\n    throw new SyntaxError(`unexpected character of value: \"${value}\"`);\n  }\n\n  return {\n    label,\n    value\n  };\n}\n\n/**\n * parse LTSV text.\n *\n * @private\n * @param {string} text\n * @param {boolean} strict\n * @returns {Object[]}\n */\nfunction baseParse(text, strict) {\n  const lines = String(text)\n    .replace(/(?:\\r?\\n)+$/, '')\n    .split(/\\r?\\n/);\n\n  const records = [];\n\n  for (let i = 0, len = lines.length; i < len; ++i) {\n    records[i] = baseParseLine(lines[i], strict);\n  }\n\n  return records;\n}\n\n/**\n * parse LTSV record.\n *\n * @private\n * @param {string} line\n * @param {boolean} strict\n * @returns {Object}\n */\nfunction baseParseLine(line, strict) {\n  const fields = String(line)\n    .replace(/(?:\\r?\\n)+$/, '')\n    .split('\\t');\n\n  const record = {};\n\n  for (let i = 0, len = fields.length; i < len; ++i) {\n    const { label, value } = splitField(fields[i], strict);\n\n    record[label] = value;\n  }\n\n  return record;\n}\n\n/**\n * parse LTSV text.\n *\n * @param {string} text\n * @returns {string}\n */\nexport function parse(text) {\n  return baseParse(text, false);\n}\n\n/**\n * parse LTSV record.\n *\n * @param {string} line\n * @returns {string}\n */\nexport function parseLine(line) {\n  return baseParseLine(line, false);\n}\n\n/**\n * parse LTSV text.\n *\n * @param {string} text\n * @returns {string}\n */\nexport function parseStrict(text) {\n  return baseParse(text, true);\n}\n\n/**\n * parse LTSV record.\n *\n * @param {string} line\n * @returns {string}\n */\nexport function parseLineStrict(line) {\n  return baseParseLine(line, true);\n}\n"],"names":["isValidLabel","label","test","isValidValue","value","objectToRecord","object","strict","TypeError","keys","Object","fields","i","len","length","SyntaxError","join","baseFormat","data","isArray","Array","records","push","splitField","chunk","field","String","index","indexOf","slice","baseParse","text","lines","replace","split","baseParseLine","line","record","options"],"mappings":";;;;;uLAWO,SAASA,EAAaC,SACpB,oBAAoBC,KAAKD,GAS3B,SAASE,EAAaC,SAEpB,kCAAkCF,KAAKE,GCPhD,SAASC,EAAeC,EAAQC,MACf,OAAXD,GAAqC,iBAAXA,QACtB,IAAIE,UAAU,kCAGhBC,EAAOC,OAAOD,KAAKH,GACnBK,EAAS,OAEV,IAAIC,EAAI,EAAGC,EAAMJ,EAAKK,OAAQF,EAAIC,IAAOD,EAAG,OACzCX,EAAQQ,EAAKG,GACbR,EAAQE,EAAOG,EAAKG,OAEtBL,IAAWP,EAAaC,SACpB,IAAIc,+CAA+Cd,SAGvDM,IAAWJ,EAAaC,SACpB,IAAIW,+CAA+CX,MAG3DO,EAAOC,GAAKX,EAAQ,IAAMG,SAGrBO,EAAOK,KAAK,MAYrB,SAASC,EAAWC,EAAMX,SAClBY,EAAUC,MAAMD,QAAQD,OAEzBC,IAAqB,OAATD,GAAiC,iBAATA,SACjC,IAAIV,UAAU,yCAGhBa,EAAU,MAEZF,MACG,IAAIP,EAAI,EAAGC,EAAMK,EAAKJ,OAAQF,EAAIC,IAAOD,EAC5CS,EAAQT,GAAKP,EAAea,EAAKN,GAAIL,QAGvCc,EAAQC,KAAKjB,EAAea,EAAMX,WAG7Bc,EAAQL,KAAK,MCpDtB,SAASO,EAAWC,EAAOjB,SACnBkB,EAAQC,OAAOF,GACfG,EAAQF,EAAMG,QAAQ,SAEb,IAAXD,QACI,IAAIZ,8CAA8CU,YAGpDxB,EAAQwB,EAAMI,MAAM,EAAGF,GACvBvB,EAAQqB,EAAMI,MAAMF,EAAQ,MAE9BpB,IAAWP,EAAaC,SACpB,IAAIc,+CAA+Cd,SAGvDM,IAAWJ,EAAaC,SACpB,IAAIW,+CAA+CX,YAGpD,CACLH,MAAAA,EACAG,MAAAA,GAYJ,SAAS0B,EAAUC,EAAMxB,SACjByB,EAAQN,OAAOK,GAClBE,QAAQ,cAAe,IACvBC,MAAM,SAEHb,EAAU,OAEX,IAAIT,EAAI,EAAGC,EAAMmB,EAAMlB,OAAQF,EAAIC,IAAOD,EAC7CS,EAAQT,GAAKuB,EAAcH,EAAMpB,GAAIL,UAGhCc,EAWT,SAASc,EAAcC,EAAM7B,SACrBI,EAASe,OAAOU,GACnBH,QAAQ,cAAe,IACvBC,MAAM,MAEHG,EAAS,OAEV,IAAIzB,EAAI,EAAGC,EAAMF,EAAOG,OAAQF,EAAIC,IAAOD,EAAG,OAC3CX,MAAEA,EAAFG,MAASA,GAAUmB,EAAWZ,EAAOC,GAAIL,GAE/C8B,EAAOpC,GAASG,SAGXiC,WDNF,SAAgBnB,UACdD,EAAWC,GAAM,mBAUnB,SAAsBA,UACpBD,EAAWC,GAAM,gBAYnB,SAAmBA,EAAMoB,EAAU,UAClC/B,OAAEA,GAAS,GAAU+B,SAEpBrB,EAAWC,EAAMX,YCZnB,SAAewB,UACbD,EAAUC,GAAM,gBASlB,SAAmBK,UACjBD,EAAcC,GAAM,kBAStB,SAAqBL,UACnBD,EAAUC,GAAM,sBASlB,SAAyBK,UACvBD,EAAcC,GAAM"}