{"version":3,"sources":["../src/parser.mjs"],"names":["splitField","chunk","strict","field","String","index","indexOf","SyntaxError","label","slice","value","baseParse","text","lines","replace","split","records","i","len","length","baseParseLine","line","fields","record","parse","parseLine","parseStrict","parseLineStrict"],"mappings":";;;;;;;;;;AAAA;;AAEA;;;;;;;;;AASA,SAASA,UAAT,CAAoBC,KAApB,EAA2BC,MAA3B,EAAmC;AACjC,QAAMC,KAAK,GAAGC,MAAM,CAACH,KAAD,CAApB;AACA,QAAMI,KAAK,GAAGF,KAAK,CAACG,OAAN,CAAc,GAAd,CAAd;;AAEA,MAAID,KAAK,KAAK,CAAC,CAAf,EAAkB;AAChB,UAAM,IAAIE,WAAJ,CAAiB,kCAAiCJ,KAAM,GAAxD,CAAN;AACD;;AAED,QAAMK,KAAK,GAAGL,KAAK,CAACM,KAAN,CAAY,CAAZ,EAAeJ,KAAf,CAAd;AACA,QAAMK,KAAK,GAAGP,KAAK,CAACM,KAAN,CAAYJ,KAAK,GAAG,CAApB,CAAd;;AAEA,MAAIH,MAAM,IAAI,CAAC,6BAAaM,KAAb,CAAf,EAAoC;AAClC,UAAM,IAAID,WAAJ,CAAiB,mCAAkCC,KAAM,GAAzD,CAAN;AACD;;AAED,MAAIN,MAAM,IAAI,CAAC,6BAAaQ,KAAb,CAAf,EAAoC;AAClC,UAAM,IAAIH,WAAJ,CAAiB,mCAAkCG,KAAM,GAAzD,CAAN;AACD;;AAED,SAAO;AACLF,IAAAA,KADK;AAELE,IAAAA;AAFK,GAAP;AAID;AAED;;;;;;;;;AAOA,SAASC,SAAT,CAAmBC,IAAnB,EAAyBV,MAAzB,EAAiC;AAC/B,QAAMW,KAAK,GAAGT,MAAM,CAACQ,IAAD,CAAN,CACXE,OADW,CACH,aADG,EACY,EADZ,EAEXC,KAFW,CAEL,OAFK,CAAd;AAGA,QAAMC,OAAO,GAAG,EAAhB;;AAEA,OAAK,IAAIC,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGL,KAAK,CAACM,MAA5B,EAAoCF,CAAC,GAAGC,GAAxC,EAA6C,EAAED,CAA/C,EAAkD;AAChDD,IAAAA,OAAO,CAACC,CAAD,CAAP,GAAajB,UAAU,CAACa,KAAK,CAACI,CAAD,CAAN,EAAWf,MAAX,CAAvB;AACD;;AAED,SAAOc,OAAP;AACD;AAED;;;;;;;;;AAOA,SAASI,aAAT,CAAuBC,IAAvB,EAA6BnB,MAA7B,EAAqC;AACnC,QAAMoB,MAAM,GAAGlB,MAAM,CAACiB,IAAD,CAAN,CACZP,OADY,CACJ,aADI,EACW,EADX,EAEZC,KAFY,CAEN,IAFM,CAAf;AAGA,QAAMQ,MAAM,GAAG,EAAf;;AAEA,OAAK,IAAIN,CAAC,GAAG,CAAR,EAAWC,GAAG,GAAGI,MAAM,CAACH,MAA7B,EAAqCF,CAAC,GAAGC,GAAzC,EAA8C,EAAED,CAAhD,EAAmD;AAAA,wBACxBjB,UAAU,CAACsB,MAAM,CAACL,CAAD,CAAP,EAAYf,MAAZ,CADc;AAAA,UACzCM,KADyC,eACzCA,KADyC;AAAA,UAClCE,KADkC,eAClCA,KADkC;;AAGjDa,IAAAA,MAAM,CAACf,KAAD,CAAN,GAAgBE,KAAhB;AACD;;AAED,SAAOa,MAAP;AACD;;AAEM,SAASC,KAAT,CAAeZ,IAAf,EAAqB;AAC1B,SAAOD,SAAS,CAACC,IAAD,EAAO,KAAP,CAAhB;AACD;;AAEM,SAASa,SAAT,CAAmBJ,IAAnB,EAAyB;AAC9B,SAAOD,aAAa,CAACC,IAAD,EAAO,KAAP,CAApB;AACD;;AAEM,SAASK,WAAT,CAAqBd,IAArB,EAA2B;AAChC,SAAOD,SAAS,CAACC,IAAD,EAAO,IAAP,CAAhB;AACD;;AAEM,SAASe,eAAT,CAAyBN,IAAzB,EAA+B;AACpC,SAAOD,aAAa,CAACC,IAAD,EAAO,IAAP,CAApB;AACD","sourcesContent":["import { isValidLabel, isValidValue } from './validator.mjs';\n\n/**\n * split to label and value from field.\n *\n * @private\n * @param {string} chunk\n * @param {boolean} strict\n * @return {Object}\n * @throws {SyntaxError}\n */\nfunction splitField(chunk, strict) {\n  const field = String(chunk);\n  const index = field.indexOf(':');\n\n  if (index === -1) {\n    throw new SyntaxError(`field separator is not found: \"${field}\"`);\n  }\n\n  const label = field.slice(0, index);\n  const value = field.slice(index + 1);\n\n  if (strict && !isValidLabel(label)) {\n    throw new SyntaxError(`unexpected character of label: \"${label}\"`);\n  }\n\n  if (strict && !isValidValue(value)) {\n    throw new SyntaxError(`unexpected character of value: \"${value}\"`);\n  }\n\n  return {\n    label,\n    value\n  };\n}\n\n/**\n *\n * @private\n * @param {string} text\n * @param {boolean} strict\n * @return {Object[]}\n */\nfunction baseParse(text, strict) {\n  const lines = String(text)\n    .replace(/(?:\\r?\\n)+$/, '')\n    .split(/\\r?\\n/);\n  const records = [];\n\n  for (let i = 0, len = lines.length; i < len; ++i) {\n    records[i] = splitField(lines[i], strict);\n  }\n\n  return records;\n}\n\n/**\n *\n * @private\n * @param {string} line\n * @param {boolean} strict\n * @return {Object}\n */\nfunction baseParseLine(line, strict) {\n  const fields = String(line)\n    .replace(/(?:\\r?\\n)+$/, '')\n    .split('\\t');\n  const record = {};\n\n  for (let i = 0, len = fields.length; i < len; ++i) {\n    const { label, value } = splitField(fields[i], strict);\n\n    record[label] = value;\n  }\n\n  return record;\n}\n\nexport function parse(text) {\n  return baseParse(text, false);\n}\n\nexport function parseLine(line) {\n  return baseParseLine(line, false);\n}\n\nexport function parseStrict(text) {\n  return baseParse(text, true);\n}\n\nexport function parseLineStrict(line) {\n  return baseParseLine(line, true);\n}\n"],"file":"parser.js"}