{"version":3,"sources":["../src/stream.mjs"],"names":["LtsvToJsonStream","Transform","constructor","options","decodeStrings","objectMode","encoding","strict","parse","parseLineStrict","parseLine","buffer","decoder","StringDecoder","_push","text","isFlush","callback","next","last","error","index","indexOf","length","line","slice","record","e","result","push","JSON","stringify","_transform","chunk","write","_flush","end","createLtsvToJsonStream"],"mappings":"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","sourcesContent":["import { Transform } from 'stream';\nimport { StringDecoder } from 'string_decoder';\n\nimport { parseLine, parseLineStrict } from './parser.mjs';\n\n/**\n * LTSV to JSON transform stream.\n */\nexport class LtsvToJsonStream extends Transform {\n  /**\n   * constructor.\n   *\n   * @param {Object} options\n   * @param {string} options.encoding\n   * @param {boolean} options.objectMode\n   * @param {boolean} options.strict\n   */\n  constructor(options = {}) {\n    super({\n      ...options,\n      decodeStrings: true,\n      objectMode: true\n    });\n\n    const { encoding = 'utf8', objectMode = false, strict = false } = options;\n\n    this.objectMode = objectMode;\n    this.parse = strict ? parseLineStrict : parseLine;\n\n    this.buffer = '';\n    this.decoder = new StringDecoder(encoding);\n  }\n\n  /**\n   * transform and push to stream.\n   *\n   * @private\n   * @param {string} text\n   * @param {boolean} isFlush\n   * @param {Function} callback\n   */\n  _push(text, isFlush, callback) {\n    let next = 0;\n    let last = 0;\n    let error = null;\n\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      let index = text.indexOf('\\n', next);\n\n      if (index === -1) {\n        if (isFlush && next < text.length) {\n          // NOTE: subtract 1 from text.length,\n          // NOTE: because add 1 to index when slice.\n          index = text.length - 1;\n        } else {\n          break;\n        }\n      }\n\n      // NOTE: include `\\n`.\n      // NOTE: foo:foo\\tbar:bar\\nfoo:foo\\tbar:bar\\n\n      // NOTE: -----------------|\n      const line = text.slice(next, index + 1);\n\n      let record;\n\n      try {\n        record = this.parse(line);\n      } catch (e) {\n        error = e;\n      }\n\n      if (error) {\n        break;\n      }\n\n      const result = this.push(\n        this.objectMode ? record : JSON.stringify(record)\n      );\n\n      if (result) {\n        // NOTE: save next start index.\n        // NOTE: foo:foo\\tbar:bar\\nfoo:foo\\tbar:bar\\n\n        // NOTE: ------------------|\n        last = next = index + 1;\n      } else {\n        break;\n      }\n    }\n\n    this.buffer = text.slice(last);\n\n    callback(error);\n  }\n\n  /**\n   * _transform implementation.\n   *\n   * @private\n   * @param {Buffer|string|*} chunk\n   * @param {string} encoding\n   * @param {Function} callback\n   */\n  _transform(chunk, encoding, callback) {\n    this._push(this.buffer + this.decoder.write(chunk), false, callback);\n  }\n\n  /**\n   * _flush implementation.\n   *\n   * @private\n   * @param {Function} callback\n   */\n  _flush(callback) {\n    this._push(this.buffer + this.decoder.end(), true, callback);\n  }\n}\n\n/**\n * create LtsvToJsonStream instance.\n *\n * @param {Object} options\n * @return {LtsvToJsonStream}\n * @see LtsvToJsonStream\n */\nexport function createLtsvToJsonStream(options) {\n  return new LtsvToJsonStream(options);\n}\n"],"file":"stream.js"}